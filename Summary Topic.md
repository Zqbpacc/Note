1. 介绍webpack和gulp，及在项目中的具体使用？

   ```
   webpack和gulp等项目构建工具
   webpack:静态模块打包器
   gulp：自动化构建工具
   
   相同点：都可用于项目打包，文件压缩，文件监测等功能。
   
   不同点：两种工具的侧重点不同，webpack主要侧重于模块的打包，适合于单页面的项目，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。而gulp侧重于前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。
   ```

2. ES6的了解？

   ```
   一、新的变量声明方式 let/const
   	let： 块级作用域，不会变量提升，暂时性死区
   	const： 声明常量
   二、箭头函数的使用
   三、模板字符串
   四、解构赋值
   五、扩展运算符
   六、Class
   七、Promise
   八、继承extends  super（）构造函数的继承
   在ES6中，会默认采用严格模式
   ```

3. 介绍Vue, React, Angular，及其区别？

   ```
   VUE渐进式框架
   react快速构建用户界面的JS库
   
   Vue与Angular相同点：
   	指令和自定义指令；
   	支持双向绑定；
   	都支持过滤器；
     不同点：
   	在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；
   	Vue.js使用基于依赖追踪的观察并且使用异步队列更新。所有的数据都是独立触发的；
   	
   Vue与React的相同点：
   	一切都是组件，组件实例之间可以嵌套；
   	在组件开发中都支持mixins的特性；
   	都提供合理的钩子函数，可以让开发者定制化地去处理需求
     不同点：
     	Vue用js插值表达式，react是JSX；
     	React依赖Virtual DOM,而Vue.js使用的是DOM模板。React采用的Virtual DOM会对渲染出来的结果做脏检查
   ```

4. CSS引入的方式？link和import的区别？

   ```
   1. link属于XHTML标签，而@import是CSS提供的一种方式
   2. 当一个页面被加载时link引用的CSS会同时被加载，@import引用的CSS会等到页面加载完毕后加载
   3. @import是CSS2.1时提出的，所以老的浏览器不支持， 而link无此问题
   4. 当使用js控制DOM 去改变样式时必须用link，因为@import不是DOM可以控制的
   ```

5. 用promise 写ajax？

   ```js
   /* ajax方法
   	 * @param  url <string> 请求的地址
   	 * @param  query <object>  请求携带的参数
   	 * @param  isJson <boolean>  是否是json格式的数据	
   	*/
   
   	ajaxGetPromise : function (url, query, isJson) {
   		isJson = isJson === undefined ? true : isJson;
   		// 如果有query再url后面拼接query
   		if(query){
   			url += "?";
   			for(var key in query){
   				url += key+"="+query[key]+"&";
   			}
   			url = url.slice(0, -1);
   		}
   		return new Promise((resolve, reject) => {
   			let ajax = new XMLHttpRequest();
   			ajax.open("GET", url, true);
   			ajax.send(null);
   			ajax.onreadystatechange = function () {
   				if(ajax.readyState === 4){
   					if(ajax.status === 200){
   						// 数据成功返回了
   						resolve(isJson ? JSON.parse(ajax.responseText) : ajax.responseText);
   					}else{
   						reject();
   					}
   				}
   			}
   		})
   	}
   }
   ```

6. 描述 call 和 apply 函数的作用及用法?

7. 并发和并行的区别

   ```
   	并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。(node  不使用密集型应用)
   	并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。
   ```

8. 什么是回调函数、特点、如何解决回调地狱？

   ```
   回调函数： callback
   
   概念： 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。
   
   回调函数：
   	不能使用try catch捕获错误；
   	不能return
   	
   回调地狱：
   	嵌套函数存在耦合性，一旦有所改动就可能影响某些代码功能；
   	嵌套函数一般很难处理错误；
   ```

9. async 和 await的特点，await的原理？
      async： 异步、await： 等待

   一个函数加上async，该函数就会返回一个promise；

   ```js
   // async语法： 在函数前面添加async关键字
      async function timeout() {
          return 'hello world'
      }
      timeout();
      console.log('虽然在后面，但是我先执行');
   ```

   await只能配套async使用；

10. 常用定时器函数

    ```js
     setTimeout（超时定时器）、setInterval（间隔定时器）、requestAnimationFrame（循环定时器）
    
     setTimeout 会比 promise后执行
    ```

    11. 进程与线程区别？JS 单线程带来的好处？

   ```
      进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。
   线程是进程中的更小单位，描述了执行一段指令所需的时间。
      JS单线程可以达到节省内存，节约上下文切换时间，没有锁的问题的好处；    
      
      把这些概念拿到浏览器中来说，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。
   ```

12. 什么是执行栈？

    ```
     栈： 一种存放数据的内存区域；
    
       调用栈
       （1）当脚本要调用一个函数时，解析器把该函数添加到栈中并且执行这个函数。并形成一个栈帧 
       （2）任何被这个函数调用的函数会进一步添加到调用栈中，形成另一个栈帧,并且运行到它们被上个程序调用的位置。 
    	（3）当执行完这个函数后，如果它没有调用其他函数，则它会从调用栈中推出。然后调用栈继续运行其他部门。 
        （4) 异步函数的回调函数一般都会被添加到运行队列里面，如settimeout会在响应的时间后把回调函数放入队列中，队列里的函数需要等栈为空时才会被推入栈中执行。如果队列中有其他函数，需要等队列前面的函数被堆入调用栈中之后才会运行。
    ```

13. new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？ 

    ```
    在调用 new 的过程中会发生以上四件事情：
    
       新生成了一个对象
       链接到原型
       绑定 this
       返回新对象
    
       使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题，所以更推荐使用字面量的方式创建对象。
    ```

14. **跨域请求资源的几种方式**

    ```
    由于浏览器同源策略，凡是发送请求URL的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。
    
    （1）JSONP（jsonp跨域get请求） 
        这种方式主要是通过动态创建一个script标签，浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行；（创建script标签向不同域提交http请求的不会被拒绝的方法，jsonp标签的src属性是没有跨域限制的）
        实际项目中JSONP通常用来获取json格式数据，这时前后端通常约定一个参数callback，该参数的值，就是处理返回数据的函数名称；
    
    缺点：这种方式无法发送post请求，另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判断。
    
    
    
    （2）proxy 代理
    这种方式首先将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端；需要注意的是如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书或者忽略证书检查，否则你的请求无法成功。
    
    （3）cors
    当你使用XMLHttpRequest发送请求时，浏览器发现该请求不符合同源策略，会给该请求头origin，后台进行一系列处理，如果确定接受请求则在返回结果加入一个响应头Access-Control-Allow-Origin；浏览器判断该响应头中是否包含Origin的值，如果有则浏览器会处理响应，我们就可以拿到响应数据，如果不0这时我们无法拿到响应数据； 
    ```

15. 监控

    ```
    页面埋点、性能监控、异常监控。
    
    页面埋点 {
    	PV / UV
    	停留时长
    	流量来源
    	用户交互
    	（归纳为手写埋点和无埋点的方式）
    }
    
    性能监控{
    	只需要调用 performance.getEntriesByType('navigation')
    }
    
    异常监控{
    	代码报错、接口异常上报。
    }
    ```

16. UDP 与 TCP 的区别是什么？

    ```
    传输的两个协议：UDP  TCP；
    
    1. UDP 协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方。
    2. UDP 不支持一对一的传输方式，支持一对多，多对多，多对一的方式（单播，多播，广播）。
    3. UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。
    
    TCP
    1. 链接需要三次握手（状态机）
    
    ARQ 超时重传机制（ARQ 协议包含停止等待 ARQ 和连续 ARQ 两种协议。）
    
    	面向无连接：
    在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
    在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作
    	UDP 头部包含了以下几个数据
    两个十六位的端口号，分别为源端口（可选字段）和目标端口
    整个数据报文的长度
    整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误
    ```

17. HTTP 及 TLS？

    ```
    HTTP 请求由三部分构成，分别为：
    
    请求行
    首部
    实体
    
    HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。
    
    TLS 协议位于传输层之上，应用层之下,首次进行 TLS 协议传输需要两个 RTT ，接下来可以通过 Session Resumption 减少到一个 RTT。
    在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密
    ```

18. Post 和 Get 的区别？

    ```
    1. Get 请求能缓存，Post 不能
    2. Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里（当然你想写到 body 里也是可以的），且会被浏览器保存历史纪录。Post 不会，但是在抓包的情况下都是一样的。
    3. URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
    4. Post 支持更多的编码类型且不对数据类型限制
    ```

19. 常见状态码？

    ```
    2XX 成功
    200 OK，表示从客户端发来的请求在服务器端被正确处理
    204 No content，表示请求成功，但响应报文不含实体的主体部分
    205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
    206 Partial Content，进行范围请求
    
    3XX 重定向
    301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
    302 found，临时性重定向，表示资源临时被分配了新的 URL
    303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源
    304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
    307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求
    
    4XX 客户端错误
    400 bad request，请求报文存在语法错误
    401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
    403 forbidden，表示对请求资源的访问被服务器拒绝
    404 not found，表示在服务器上没有找到请求的资源
    
    5XX 服务器错误
    500 internal sever error，表示服务器端在执行请求时发生了错误
    501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
    503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求
    ```

20. http1.1和http2？

    ```
    http/1:因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。（对头阻塞）
    
    在 HTTP/2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输(多路复用)
    
    HTTP/2 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的
    QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议
    ```

21. 输入 URL 到页面渲染的整个流程？

    ```
    简介：
    DNS：就是通过域名查询到的具体的IP，而 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。在TCP握手之前就进行了DNS查询；
    www.google.com
    1. 操作系统会首先在本地缓存中查询 IP
    2. 没有的话会去系统配置的 DNS 服务器中查询
    3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一3级域名的服务器
    4. 然后去该服务器查询 google 这个二级域名
    5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP  
    (迭代查询（客户端做请求）/递归查询（DNS服务器请求的结果返回客户端）)
    6. TCP握手， 应用层下发数据给传输层，此时TCP协议指明两段的端口号然后下发给网路层；网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。
    7. 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，判断当前的状态码，200继续解析、500 400就会报错、300就会重定向
    8. 开始渲染
    ```

22. 渲染流程？

    ```
    1. 渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。
    
    2. CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西
    
    3. 在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。
    ```

23. 设计模式有哪些？

    ```
    1. 工厂模式（Vue创建异步组件）
    2. 单例模式（全局缓存、全局状态管理等等这些只需要一个对象）
    3. 适配器模式（适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。）
    4. 装饰模式（装饰模式不需要改变已有的接口，作用是给对象添加功能）
    5. 代理模式（控制对象的访问，不让外部直接访问对象）
    6. 发布-订阅模式（观察者模式： 点击事件）
    7. 外观模式（提供一个接口，隐藏内部的逻辑，更加方便外部的调用）（添加事件）
    ```

24. 斐波那契数列？

    ```
    function fib(n) {
      if (n < 2 && n >= 0) return n
      return fib(n - 1) + fib(n - 2)
    }
    fib(10)
    ```

25. export default 和 module.export 的区别？

    CommonJS规范：

    CommonJS定义的模块分为: 模块标识(module)、模块定义(exports) 、模块引用(require)

    ```txt
    require: node 和 es6 都支持的引入(CommonJS规范)
    export / import : 只有es6 支持的导出引入
    module.exports / exports: 只有 node 支持的导出(CommonJS规范)
    exports = module.exports 都指向同一个内存地址
    
    1. require方法用于加载模块;
    2. module变量代表当前模块。这个变量是一个对象，module对象会创建一个叫exports的属性，这个属性的默认值是一个空的对象：
    3. export 对应的 import，相当于 export { default sa }  from "";
    4. export default在一个模块中只能有一个，当然也可以没有。export在一个模块中可以有多个。
    5. export default的对象、变量、函数、类，可以没有名字。export的必须有名字。
    6. export default对应的import和export有所区别
    ```

    ```
    ES6
    export 和 export default的区别:
    
    1. 在一个文件或模块中，export、import可以有多个，export default仅有一个
    2. 通过export方式导出，在导入时要加{ }，export default则不需要
    3. export能直接导出变量表达式，export default不行。
    ```

    

    

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   